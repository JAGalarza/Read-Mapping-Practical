<!DOCTYPE html>
<html>

<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>Read_Mapping_Juan</title>


<style type="text/css">
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body > *:first-child {
  margin-top: 0 !important; }
body > *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
  text-decoration: none; }

h1 tt, h1 code {
  font-size: inherit; }

h2 tt, h2 code {
  font-size: inherit; }

h3 tt, h3 code {
  font-size: inherit; }

h4 tt, h4 code {
  font-size: inherit; }

h5 tt, h5 code {
  font-size: inherit; }

h6 tt, h6 code {
  font-size: inherit; }

h1 {
  font-size: 28px;
  color: black; }

h2 {
  font-size: 24px;
  border-bottom: 1px solid #cccccc;
  color: black; }

h3 {
  font-size: 18px; }

h4 {
  font-size: 16px; }

h5 {
  font-size: 14px; }

h6 {
  color: #777777;
  font-size: 14px; }

p, blockquote, ul, ol, dl, li, table, pre {
  margin: 15px 0; }

hr {
  background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
  border: 0 none;
  color: #cccccc;
  height: 4px;
  padding: 0;
}

body > h2:first-child {
  margin-top: 0;
  padding-top: 0; }
body > h1:first-child {
  margin-top: 0;
  padding-top: 0; }
  body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
  margin-top: 0;
  padding-top: 0; }

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0; }

h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
  margin-top: 0; }

li p.first {
  display: inline-block; }
li {
  margin: 0; }
ul, ol {
  padding-left: 30px; }

ul :first-child, ol :first-child {
  margin-top: 0; }

dl {
  padding: 0; }
  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; }
    dl dt:first-child {
      padding: 0; }
    dl dt > :first-child {
      margin-top: 0; }
    dl dt > :last-child {
      margin-bottom: 0; }
  dl dd {
    margin: 0 0 15px;
    padding: 0 15px; }
    dl dd > :first-child {
      margin-top: 0; }
    dl dd > :last-child {
      margin-bottom: 0; }

blockquote {
  border-left: 4px solid #dddddd;
  padding: 0 15px;
  color: #777777; }
  blockquote > :first-child {
    margin-top: 0; }
  blockquote > :last-child {
    margin-bottom: 0; }

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

img {
  max-width: 100%; }

span.frame {
  display: block;
  overflow: hidden; }
  span.frame > span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; }
  span.frame span img {
    display: block;
    float: left; }
  span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; }
span.align-center {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-center > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; }
  span.align-center span img {
    margin: 0 auto;
    text-align: center; }
span.align-right {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-right > span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; }
  span.align-right span img {
    margin: 0;
    text-align: right; }
span.float-left {
  display: block;
  margin-right: 13px;
  overflow: hidden;
  float: left; }
  span.float-left span {
    margin: 13px 0 0; }
span.float-right {
  display: block;
  margin-left: 13px;
  overflow: hidden;
  float: right; }
  span.float-right > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; }

code, tt {
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px; }

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent; }

.highlight pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }
  pre code, pre tt {
    background-color: transparent;
    border: none; }

sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}

kbd {
  display: inline-block;
  padding: 3px 5px;
  font-size: 11px;
  line-height: 10px;
  color: #555;
  vertical-align: middle;
  background-color: #fcfcfc;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #bbb
}

* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:0 auto;
    }
}
@media print {
	table, pre {
		page-break-inside: avoid;
	}
	pre {
		word-wrap: break-word;
	}
  body {
    padding: 2cm; 
  }
}
</style>


</head>

<body>

<h2 id="toc_0">Read Mapping</h2>

<p><em>Juan Galarza (juan.galarza@jyu.fi), February 2021.</em></p>

<p>Now that we have our assembled transcripts by Trinity, it is time to map the reads to them. But first some clarifying concepts.</p>

<h3 id="toc_1">Mapping vs Alignment</h3>

<p>At this point you might have heard of mapping the reads and aligning the reads. These are often used interchangeably but differ fundamentally. </p>

<p>In the simplest of terms, mapping and alignment are way of arranging sequences of DNA, RNA, or protein to identify regions of similarity.</p>

<p>Mapping: Finds the <strong>approximate</strong> <strong>origin</strong> of a sequence. Where in the genome did the read originate.</p>

<p>Alignment: Finds the <strong>exact</strong> <strong>difference</strong> between two sequences.</p>

<div><pre><code class="language-none">Alignment example:

GTGGTGCATCTGTTCTCCCCCGGCGGGAAGTACGACTCGCTGTATATG
||||||||||||||_||_||___|||_|||||||||||||||||||||
GTGGTGCATCTGTTTTCGCCAAACGGTAAGTACGACTCGCTGTATATG 

Mapping example:

GTGGTGCATCTGTTCTCCCCCGGCGGGAAGTA   oqxB_EU370913</code></pre></div>

<p>Mapping is part of alignment</p>

<p><img align="justify" width="500 height="500" src="https://raw.githubusercontent.com/JAGalarza/ECOS1179-2021/main/Alignment-mapping.jpeg"></p>

<ul>
<li>A mapping is a region of the reference sequence where the read is placed</li>
<li>A mapping is regarded to be correct if overlaps the true region</li>
<li>An alignment is the detailed placement of each base of the read in the reference sequence</li>
<li>An alignment is regarded to be correct if only if each base is placed correctly.<br></li>
</ul>

<p>Currently there are over 90 NGS read aligners that differ in</p>

<ul>
<li>Speed</li>
<li>Accuracy</li>
<li>Approach</li>
<li>Purpose</li>
</ul>

<p>Choosing which to use not always straightforward.</p>

<p><img align="justify" width="750" height="700" src="https://raw.githubusercontent.com/JAGalarza/ECOS1179-2021/main/Aligners_Trhough_time.jpeg"></p>

<p><br></p>

<p>Why use mapping, if it is included in alignment?<br>
<br></p>

<ol>
<li><p>Mapping is (much) faster, and computationally easier to solve, as we shall see below.</p></li>
<li><p>You might not be interested in the precise differences, but merely want to know the approximate origin.
<br>
<br></p></li>
</ol>

<p>Two of the main applications of mapping include genotyping, where the goal is to identify variations</p>

<p><img src="https://raw.githubusercontent.com/JAGalarza/ECOS1179-2021/main/mapping_DNA.jpeg" alt="drawing" width="500" height="200"/></p>

<p>and RNA-Seq, in which we want to identify and measure significant mapping peaks</p>

<p><img src="https://raw.githubusercontent.com/JAGalarza/ECOS1179-2021/main/mapping-RNA.jpeg" alt="drawing" width="500" height="220"/></p>

<p><strong>Popular mapping methods:</strong></p>

<ol>
<li>KmerFinder</li>
<li>Kraken</li>
<li>Kallisto</li>
<li>Salmon</li>
<li>KMA-Sparse</li>
</ol>

<p><strong>Popular alignment methods:</strong></p>

<ol>
<li>BLAST</li>
<li>Bowtie2</li>
<li>BWA-MEM </li>
<li>GraphMap </li>
<li>MiniMap2</li>
<li>KMA</li>
</ol>

<h2 id="toc_2">The mapping problem</h2>

<p>Sequencing technologies nowadays are are capable of producing several millions of reads (Table 1), and with high throughput comes high error. The mapping process thus must be tolerant of mismatches, insertions, and deletions, in order to correctly distinguish between sequencing errors and genuine differences.</p>

<table>
<thead>
<tr>
<th style="text-align: left">Platform</th>
<th style="text-align: center">Reads/run</th>
<th style="text-align: center">Accuracy</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Roche 454</td>
<td style="text-align: center">1 Million</td>
<td style="text-align: center">99%</td>
</tr>
<tr>
<td style="text-align: left">Illumina</td>
<td style="text-align: center">~ 3 billion</td>
<td style="text-align: center">99%</td>
</tr>
<tr>
<td style="text-align: left">SOLiD</td>
<td style="text-align: center">~1.4 billion</td>
<td style="text-align: center">98%</td>
</tr>
<tr>
<td style="text-align: left">Ion Torrent</td>
<td style="text-align: center">&lt; 5 million</td>
<td style="text-align: center">98%</td>
</tr>
<tr>
<td style="text-align: left">Pacific Biosciences</td>
<td style="text-align: center">2 million</td>
<td style="text-align: center">97%</td>
</tr>
</tbody>
</table>

<p><strong>Table 1.</strong> Basic specs of common Next-gen platforms.</p>

<p>Errors can originate from: 
<img align="right" width="250" height="170" src="https://raw.githubusercontent.com/JAGalarza/ECOS1179-2021/main/garbage_in.jpeg"></p>

<ul>
<li><p>Instrument weirdness </p></li>
<li><p>Duplicate reads (PCR duplication)</p></li>
<li><p>Indel errors (Skipping bases, inserting extra bases)</p></li>
<li><p>Uncalled bases (Unreliable signal, replace with ”N”)</p></li>
<li><p>Substitution errors (Reading wrong bases)</p></li>
</ul>

<p><br></p>

<p>Why not just use BLAST)?</p>

<p>Assuming BLAST returns the result for a read in 1 sec, for 10 million reads: 10 million seconds = 116 days. More efficient algorithms are needed.</p>

<h2 id="toc_3">Mapping Strategies</h2>

<p><div style="text-align: justify"> 
Current mapping strategies can be broadly divided into two main categories:
<strong>Hash Table</strong> (Lookup table, dynamic programming) FAST, but requires perfect matches. </p>

<p><strong>Burrows-Wheeler Transform</strong> (BW Transform) FAST.
Memory efficient. But for gaps/mismatches, it lacks sensitivity.</p>

<p>Both of these require that the reference genome (or transcriptome) to which the reads will be aligned (or mapped) be indexed. There are many ways to index a reference genome. In the simplest of terms, the index is a list of files that comprise the genome sequence, suffix arrays with corresponding positions, chromosome (or transcript) names and lengths, and splice junctions coordinates. You may think of an index as in a book index, where if you need to find a particular information, you don&#39;t look page by page for it. You look in the index first.</p>

<p>Index entries are generally in a form of <code>&lt;key&gt;&lt;value&gt;</code>. Suppose that you wish to find the motif <code>TGC</code>in the sequence <code>GACTCGGATCTCGACATCG</code>. The corresponding index entry for this motif will be <code>345;789</code>. That is, the <code>key&gt;TGC</code> has a value of <code>345;789</code>, which corresponds to positions <code>345</code> and <code>789</code> in the reference sequence. This index entry is stored in a table that can be quickly accesses, and thus, the aligner does not have to read the full sequence to find the motif, it access the table instead.</p>

<div><pre><code class="language-none">Pos: 01234567890123456789 
Ref: GACTCGGATCTCGACATCG 
Motif:  TCG          TCG</code></pre></div>

<h1 id="toc_4">Let&#39;s start aligning!</h1>

<p>Before you begin, make sure that you logged in to Puhti using -Y option to allow graphical output from the terminal.</p>

<div><pre><code class="language-none">ssh -Y USER@puhti.csc.fi</code></pre></div>

<p>In the X directory we have a set of 6 biological samples</p>

<div><pre><code class="language-none">    LI101
    LI732
    LI74
    LI960
    LI961
    LI967</code></pre></div>

<p>The samples are paired and contain 100,000 reads in each mate pair (i.e <code>SAMPLE_1.fq</code> and <code>SAMPLE_2.fq</code>). Chose one sample with both of its mates and copy it to your working directory.</p>

<p><code>cp LI101_100k_1.fq LI101_100k_2.fq /path/to/your/working/directory
</code></p>

<p>From this point forward remember that text following &#39;#&#39; is a comment from me to you. You don&#39;t need to copy it to the terminal. Also remember that the back slash &#39;\&#39; tells the terminal that the command continues in the next line. This helps to keep our code tidy. For instance:</p>

<div><pre><code class="language-none"># this is a comment
this is a command that continues \ # a comment can also be here
in the next line.</code></pre></div>

<h3 id="toc_5">The alignment algorithm</h3>

<p>Three of the main factors impacting alignment are the read quality, the read length, and of course, the alignment algorithm. Let&#39;s start with the alignment algorithm. Most aligners offer different choices of algorithms which must be set according to your question/expectations. One of the most popular aligners is <a href="http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml">Bowtie2</a> </p>

<p>From Bowtie2 documentation we can read that it offers two types of alignment algorithms: End-to-end and Local. <code>bowtie2</code> takes a Bowtie2 index and a set of sequencing read files and outputs a set of alignments in <a href="https://samtools.github.io/hts-specs/SAMv1.pdf">SAM</a> format. </p>

<p>The first step is to index the reference transcriptome that you built in the last session. This can take some time so I already indexed it using the <code>bowtie2-build</code> <a href="http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml#the-bowtie2-build-indexer">command</a>.</p>

<p><strong>End-to-end alignment versus local alignment</strong></p>

<p>By default, Bowtie2 performs end-to-end read alignment. That is, it searches for alignments involving all of the read characters. This is also called an &quot;untrimmed&quot; or &quot;unclipped&quot; alignment.</p>

<p>When the <code>--local</code> option is specified, Bowtie2 performs local read alignment. In this mode, Bowtie2 might &quot;trim&quot; or &quot;clip&quot; some read characters from one or both ends of the alignment and in doing so maximises the alignment score.</p>

<p><strong>End-to-end alignment example</strong></p>

<p>The following is an &quot;end-to-end&quot; alignment because it involves all the characters in the read. Such an alignment can be produced by Bowtie2 in either end-to-end mode or in local mode.</p>

<div><pre><code class="language-none">Read:      GACTGGGCGATCTCGACTTCG
Reference: GACTGCGATCTCGACATCG

Alignment:
  Read:      GACTGGGCGATCTCGACTTCG
             |||||  |||||||||| |||
  Reference: GACTG--CGATCTCGACATCG</code></pre></div>

<p>Where dash symbols represent gaps and vertical bars show where aligned
characters match.</p>

<p><strong>Local alignment example</strong></p>

<p>The following is a &quot;local&quot; alignment because some of the characters at the ends
of the read do not participate.  In this case, 4 characters are omitted (or
&quot;soft trimmed&quot; or &quot;soft clipped&quot;) from the beginning and 3 characters are
omitted from the end.  This sort of alignment can be produced by Bowtie 2 only
in local mode.</p>

<div><pre><code class="language-none">Read:      ACGGTTGCGTTAATCCGCCACG
Reference: TAACTTGCGTTAAATCCGCCTGG

Alignment:
  Read:      ACGGTTGCGTTAA-TCCGCCACG
                 ||||||||| ||||||
  Reference: TAACTTGCGTTAAATCCGCCTGG</code></pre></div>

<p>Let&#39;s do an alignment with each mode and have a quick look at the results. See below the explanation for each of these parameters</p>

<div><pre><code class="language-none">bowtie2 -x Trinity_Index/Trin_index \
--end-to-end \
-t \
-p 2 \
-1 LI101_100k_1.fq \
-2 LI101_100k_2.fq \
-S LI101.end2end.sam \
2&gt; LI101.end-to-end.metrics</code></pre></div>

<p>Do another alignment using the local mode this time.</p>

<div><pre><code class="language-none">bowtie2 -x Trinity_Index/Trin_index \
--local \
-t \
-p 2 \
-1 LI101_100k_1.fq \
-2 LI101_100k_2.fq \
-S LI101.local.sam \
2&gt; LI101.local.metrics</code></pre></div>

<p>You can compare some basic alignment statistics in the <code>.metrics</code> files. Are there any differences in the number of aligned reads between the <code>local</code> and <code>end-to-end</code> alignments?. How are the <code>concordant</code> and <code>discordant</code> alignments?. Recall from previous lessons that a &quot;paired-end&quot; or &quot;mate-pair&quot; read consists of pair of mates, called mate 1 and mate 2.  Pairs come with a prior expectation about (a) the relative orientation of the mates, and (b) the distance separating them on the original DNA molecule. In Bowtie2, a pair that aligns with the expected relative mate orientation and with the expected range of distances between mates is said to align <code>concordantly</code>. If both mates have unique alignments, but the alignments do not match paired-end expectations (i.e. the mates aren&#39;t in the expected relative orientation, or aren&#39;t within the expected distance range, or both), the pair is said to align
<code>discordantly</code>.</p>

<h3 id="toc_6">Bowtie2 arguments</h3>

<p>See full documentation <a href="http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml">here</a></p>

<table><tr><td id="bowtie2-options-x">

    -x 

</td><td>

The basename of the index for the reference genome.  The basename is the name of
any of the index files up to but not including the final `.1.bt2` / `.rev.1.bt2`
/ etc.  `bowtie2` looks for the specified index first in the current directory,
then in the directory specified in the `BOWTIE2_INDEXES` environment variable.

</td></tr>
<tr><td id="bowtie2-options-1">

    -1 

</td><td>

Comma-separated list of files containing mate 1s (filename usually includes
`_1`), e.g. `-1 flyA_1.fq,flyB_1.fq`.  Sequences specified with this option must
correspond file-for-file and read-for-read with those specified in `<m2>`. Reads
may be a mix of different lengths. If `-` is specified, `bowtie2` will read the
mate 1s from the "standard in" or "stdin" filehandle.

</td></tr>
<tr><td id="bowtie2-options-2">

    -2 

</td><td>

Comma-separated list of files containing mate 2s (filename usually includes
`_2`), e.g. `-2 flyA_2.fq,flyB_2.fq`.  Sequences specified with this option must
correspond file-for-file and read-for-read with those specified in `<m1>`. Reads
may be a mix of different lengths. If `-` is specified, `bowtie2` will read the
mate 2s from the "standard in" or "stdin" filehandle.

</td></tr>
<tr><td id="bowtie2-options-U">

    -U <r>

</td><td>

Comma-separated list of files containing unpaired reads to be aligned, e.g.
`lane1.fq,lane2.fq,lane3.fq,lane4.fq`.  Reads may be a mix of different lengths.
If `-` is specified, `bowtie2` gets the reads from the "standard in" or "stdin"
filehandle.

</td></tr>

<tr><td id="end-to-end">

    --end-to-end

</td><td>

In this mode, Bowtie 2 requires that the entire read align from one end to the
other, without any trimming (or "soft clipping") of characters from either end.
This is mutually exclusive with [`--local`].  `--end-to-end` is the default mode.

</td></tr>
<tr><td id="local">

    --local

</td><td>

In this mode, Bowtie 2 does not require that the entire read align from one end
to the other.  Rather, some characters may be omitted ("soft clipped") from the
ends in order to achieve the greatest possible alignment score.  The match bonus
[`--ma`] is used in this mode, and the best possible alignment score is equal to
the match bonus ([`--ma`]) times the length of the read.  Specifying `--local`
and one of the presets (e.g. `--local --very-fast`) is equivalent to specifying
the local version of the preset (`--very-fast-local`).  This is mutually
exclusive with [`--end-to-end`].  `--end-to-end` is the default mode.


</td></tr>
<tr><td id="bowtie2-options-p">

    -p

</td><td>

Launch `NTHREADS` parallel search threads (default: 1).  Threads will run on
separate processors/cores and synchronise when parsing reads and outputting
alignments.  Searching for alignments is highly parallel, and speedup is close
to linear.  Increasing `-p` increases Bowtie 2's memory footprint. E.g. when
aligning to a human genome index, increasing `-p` from 1 to 8 increases the
memory footprint by a few hundred megabytes.  This option is only available if
`bowtie` is linked with the `pthreads` library (i.e. if `BOWTIE_PTHREADS=0` is
not specified at build time).

<tr><td id="bowtie2-options-t">

    --time

</td><td>

Print the wall-clock time required to load the index files and align the reads.
This is printed to the "standard error" ("stderr") filehandle.  Default: off.
</td></tr>
<tr><td id="bowtie2-options-5">

    --trim5 <int>

</td><td>

Trim N bases from 5' (left) end of each read before alignment (default: 0).

</td></tr>
<tr><td id="bowtie2-options-3">

    --trim3 <int>

</td><td>

Trim N bases from 3' (right) end of each read before alignment (default: 0).


</table>

<p><div style="text-align: justify"> </p>

<p>We can further explore the alignment results using <a href="http://www.htslib.org">Samtools</a>, which is a set of utilities that manipulate alignments in the SAM/BAM format. It imports from and exports to the SAM (Sequence Alignment/Map) format, does sorting, merging and indexing, and allows to retrieve reads in any regions swiftly. </p>

<p>Samtools has a variety of neat <a href="http://www.htslib.org/doc/samtools.html">utilities</a>, from which we will be using, <code>view</code> and <code>coverage</code> to explore our alignments. Start with the <code>view</code> command and relate the output to the sam format What are the fileds of your <code>.sam</code> file?. Identify them in the sam format <a href="https://samtools.github.io/hts-specs/SAMv1.pdf">descriptor</a>.</p>

<div><pre><code class="language-none"># module load biokit (if you haven&#39;t load it yet)

samtools view LI101.local.sam | head</code></pre></div>

<p>With the <code>coverage</code> command we can get more detailed information about our alignment. Let&#39;s have a peak of the output. What do the columns refer to, and which ones do you think are the most relevant to infer how good is our alignment?. You may see <a href="http://www.htslib.org/doc/samtools-coverage.html">here</a> for more detailed descriptions.    </p>

<div><pre><code class="language-none"> samtools coverage LI101.end2end.bad.sam | head | column -t</code></pre></div>

<p>Inspect the output</p>

<div><pre><code class="language-none">rname                     startpos  endpos  numreads  covbases  coverage  meandepth   meanbaseq  meanmapq
TRINITY_DN74264_c0_g1_i2   1         655     4         199       30.3817   0.305344    11.9       1
TRINITY_DN84566_c2_g1_i19  1         5539    1         48        0.866582  0.00866582  11.2       42
TRINITY_DN21378_c0_g1_i1   1         224     0         0         0         0           0          0
TRINITY_DN21326_c0_g1_i1   1         355     0         0         0         0           0          0
TRINITY_DN21358_c0_g1_i1   1         325     0         0         0         0           0          0
TRINITY_DN21300_c0_g1_i1   1         598     0         0         0         0           0          0
TRINITY_DN21328_c0_g1_i1   1         354     0         0         0         0           0          0
TRINITY_DN21388_c0_g1_i1   1         202     0         0         0         0           0          0
TRINITY_DN21388_c0_g1_i2   1         236     0         0         0         0           0          0</code></pre></div>

<h3 id="toc_7">Read quality</h3>

<p>Let&#39;s now look at the effect of read quality when performing alignments. Modern aligners make use of the quality of the reads being aligned to report some confidence in the alignment. In this particular read set, the sequencing company did the quality filtering and sent us reads of very high-quality. For the purpose of this practical, I artificially lowered the quality of the reads, keeping the read sequence intact. </p>

<p><img src="https://raw.githubusercontent.com/JAGalarza/ECOS1179-2021/main/Good-bad_qc.jpeg" alt="Alt Image Text"></p>

<p>In the <strong>X directory</strong> you will find the low-quality reads with a <code>.bad</code> suffix. Copy to your working directory the bad-quality sample file of your sample. For instance, if you choose <code>LI101_100k_1.fq</code> and <code>LI101_100k_2.fq</code>, copy the corresponding <code>LI101_100k_1.fq.bad</code> and <code>LI101_100k_2.fq.bad</code>. We will first check the quality of the reads. </p>

<p>Do the quality check with <code>fastqc</code> as you did in the previous practical.    </p>

<div><pre><code class="language-none"># load the module that contains fastqc
module load biokit 

# Create a directory to store the results
mkdir -p QC_reports 

# run fastqc in all reads
for i in $(ls *.fq*); do \
fastqc --outdir QC_reports/ $i; done</code></pre></div>

<p>Once <code>fastqc</code> finishes, we can combine all the results in a single report using <a href="https://multiqc.info">MultiQC</a>. Refer to the previous practical on quality control. 
Now run MultiQC</p>

<div><pre><code class="language-none"># we need to export these locales first
export LANG=C.UTF-8
export LC_ALL=C.UTF-8   

# MultiQC can be launched with the following command

singularity exec --bind $PWD \ # Where $PWD is your current directory
/projappl/project_2000178/course-software.simg \ # where the software lives in Puhti
multiqc . --fullnames --outdir QC_reports/ # calls the multiqc with corresponding options

# The result can be fetch from here and view in any browser.

scp -r USERNAME@puhti.csc.fi:/scratch/project_2000178/ECOS1179/Juan_Tests/QC_reports/multiqc_report.html .</code></pre></div>

<p>Have a look at how do the high- and bad-quality files compared. </p>

<p>Let&#39;s see if the bad-quality reads align as good as the high-quality ones.</p>

<div><pre><code class="language-none">bowtie2 -x Trinity_Index/Trin_index \
--end-to-end \
-t \
-p 2 \
-1 LI101_100k_1.fq.bad \
-2 LI101_100k_2.fq.bad \
-S LI101.end2end.bad.sam \
2&gt; LI101.end-to-end.bad.metrics</code></pre></div>

<p>As before, compare the <code>.metrics</code> file paying particular attention to the discordant and concordant alignments. What do you see as the main difference?.</p>

<p>Another important alignment metric is the mapping quality or MAPQC. Generally, the quality of a particular alignment is reported as −10 log10 Pr{mapping position is wrong}, rounded to the nearest integer. In plain english this means that, for instance, if the probability of a correctly mapped read is 0.99, then the corresponding MAPQ score should be 20 (i.e. log10 of 0.01 * -10). If the probability of a correct mapping is 0.999, the MAPQ score would increase to 30, and so on. This mapping quality is reported for each alignment in the fifth column of the <code>.sam</code> file that we generated above.</p>

<p>Let&#39;s extract this qualities to a file</p>

<div><pre><code class="language-none">samtools view LI101.end2end.sam | cut -f5 &gt; LI101.end2end.mapqc</code></pre></div>

<p>and make a quick histogram using R without leaving the terminal to inspect the distribution of quality values. </p>

<div><pre><code class="language-none">R --vanilla --slave -e &#39;x&lt;-read.csv(&quot;LI101.end2end.mapqc&quot;);pdf(&quot;LI101_end2end_mapqc.pdf&quot;);hist(x$X1[x$X1 &gt;1], xlab=&quot;MAPQC&quot;,col = &quot;skyblue3&quot;, breaks=seq(1,45,1));dev.off()&#39;&#39;</code></pre></div>

<p>If you logged in to puhti with ssh -Y as instructed above, you can view the plot directly from your terminal using </p>

<div><pre><code class="language-none">evince LI101_end2end_mapqc.pdf</code></pre></div>

<p>Otherwise you can download the plot to your computer as</p>

<div><pre><code class="language-none">scp -r USERNAME@puhti.csc.fi:/path/to/LI101_end2end_mapqc.pdf .</code></pre></div>

<p>Try inspecting the mapping quality indices of the different bad and high-quality samples to see what impact the read quality makes on the mapping, and thus inturn, in the alignment. Note that in this case, mapping is part of the alignment as we have discussed above.</p>

<h3 id="toc_8">Read length</h3>

<p>Let&#39;s now mess with the read length. When planing a sequencing project several options and platforms exist for obtaining sequence reads of different length. The read length is often chosen depending on the application (i.e. de novo assembly, gene expression, etc). To see the effect of read length in alignment we can use the options <code>--trim5</code> and <code>--trim3</code>. These tell Bowtie2 to ignore 50bp (or as many as you wish) from the 5&#39; or 3&#39; of the high-quality reads before the alignment.</p>

<div><pre><code class="language-none">bowtie2 -x Trinity_Index/Trin_index \
--end-to-end \
-t \
-p 2 \
--trim5 50 \
-1 LI101_100k_1.fq \
-2 LI101_100k_2.fq \
-S LI101.end2end.trim50.sam \
2&gt; LI101.end-to-end.trim50.metrics</code></pre></div>

<p>Continue playing with combinations of these parameters. Which ones do you think have the biggest impact?. What if you use only one mate of the pair (i.e. using the read<em>1 or read</em>2 as single reads with the <code>-U</code> option). Do you get comparable results as when using both mates?.</p>

<h3 id="toc_9">Expression tables</h3>

<p>Ultimately, for downstream analyses of gene expression we will need count tables, also know as expression matrices. In essence, these show how many reads aligned to a particular transcript of our reference transcriptome. Trinity, the software you used before, conveniently provides <a href="https://www.perl.org">perl</a> scripts to generate such tables. The script <code>align_and_estimate_abundance.pl</code> can be called as below to produce an expression table.</p>

<div><pre><code class="language-none">singularity exec --bind $PWD \
/projappl/project_2000178/course-software.simg \
/usr/local/bin/trinityrnaseq/util/align_and_estimate_abundance.pl \
--transcripts Trinity_Index/TrinityB.fasta \
--seqType fq \
--left LI101_100k_1.fq \
--right LI101_100k_2.fq \
--est_method RSEM \
--output_dir LI101_expr_Bowtie2 \
--aln_method bowtie2 \
--trinity_mode</code></pre></div>

<p>​<br>
After running the above command we can inspect the results printed to the <code>RSEM.genes.results</code> file. </p>

<div><pre><code class="language-none">less LI101_expr_Bowtie2/RSEM.genes.results


gene_id                 transcript_id(s)           length  effective_length  expected_count  TPM   FPKM
TRINITY_DN100000_c0_g1  TRINITY_DN100000_c0_g1_i1  241.00  73.51             0.00            0.00  0.00
TRINITY_DN100001_c0_g1  TRINITY_DN100001_c0_g1_i1  325.00  154.58            0.00            0.00  0.00
TRINITY_DN100002_c0_g1  TRINITY_DN100002_c0_g1_i1  273.00  103.66            0.00            0.00  0.00
TRINITY_DN100003_c0_g1  TRINITY_DN100003_c0_g1_i1  203.00  40.60             0.00            0.00  0.00</code></pre></div>

<p>The meaning of this output is as follows:
<strong>transcript_id</strong> is the transcript name of this transcript. <strong>length</strong> is this transcript&#39;s sequence length.
<strong>effective_length</strong> counts only the positions that generate a valid fragment. <strong>expected_count</strong> is the sum of the posterior probability that each read comes from this transcript over all reads. <strong>TPM</strong> stands for Transcripts Per Million, a relative measure of gene expression. It tells how many transcripts were found per every million bases sequenced. <strong>FPKM</strong> stands for Fragments Per Kilobase of transcript per Million mapped reads. It is another relative measure of transcript abundance. Which of these read count measures would you choose for gene expression analyses? why?.</p>

<h3 id="toc_10">Let&#39;s do some mapping now!</h3>

<p>So far we have been looking at the alignment approach with Bowtie2. We can now have a look at the mapping approach using <a href="https://pachterlab.github.io/kallisto/about">Kallisto</a> and compare both approaches.</p>

<p>Kallisto is a program for quantifying abundances of transcripts from bulk and single-cell RNA-Seq data, or more generally of target sequences using high-throughput sequencing reads. It is based on the novel idea of pseudoalignment for rapidly determining the compatibility of reads with targets, without the need for alignment. You may find the algorithm details <a href="https://bioinfo.iric.ca/understanding-how-kallisto-works/">here</a>.</p>

<p>From kallisto documentation we can read that the basic idea is to determine, for each read, not where in each transcript it aligns, but rather which transcripts it is compatible with. As such, it’s NOT necessary to do a full alignment of the reads to the genome which is often the slowest step in sequencing analysis. Instead, the raw sequence reads are directly compared to transcript sequences and then used to quantify transcript abundance. Put simply, it estimates the approximate location in the transcriptome from where the read originate. Sounds familiar? </p>

<p>As with Bowtie2, kallisto needs an index to look in. And as with Bowtie2, this can take a long time. So in the interest of time, I already generated the Kallisto index with (unsurprisingly) the <code>index</code> command.</p>

<p>Let&#39;s run Kallisto on the same samples that we ran with Bowtie2.</p>

<div><pre><code class="language-none">singularity exec --bind $PWD \
/projappl/project_2000178/course-software.simg \
kallisto quant --index Kallisto_Index/TrinityB.idx \
--output-dir Kallisto_LI101/ \
--threads 1 LI101_100k_1.fq LI101_100k_2.fq</code></pre></div>

<p>Enter the Kallisto results directory (mine is Kallisto_LI101) and inspect the <code>abundance.tsv</code> file and compare it to the R<code>SEM.genes.results</code> from Bowtie2 above.</p>

<div><pre><code class="language-none">less LI101_expr_Bowtie2/RSEM.genes.results
less Kallisto_LI101/abundance.tsv</code></pre></div>

<p>From the Kallisto output we can see that the table is not sorted as the Bowtie2 table. Let&#39;s fix that.</p>

<div><pre><code class="language-none">cat Kallisto_LI101/abundance.tsv | awk &#39;NR == 1; NR &gt; 1 {print $0 | &quot;sort -n&quot;}&#39;| less</code></pre></div>

<p>You could also compare expression values between from the alignment and mapping approaches for individual transcripts. Suppose that the transcripts TRINITY<em>DN100000</em>c0<em>g1</em>i1 and TRINITY<em>DN100006</em>c0<em>g1</em>i1 have a very interesting biological function (we will see functional annotation in the next practical), or are involved in some process that you find particularly interesting for your experiment. You could quickly compare the expression values as below:</p>

<div><pre><code class="language-none">grep -E &quot;TRINITY_DN100000_c0_g1_i1|TRINITY_DN100006_c0_g1_i1&quot; LI101_expr_Bowtie2/RSEM.genes.results Kallisto_LI101/abundance.tsv</code></pre></div>

<p>What general conclusions can you draw about what to consider when performing read mapping for downstream gene expression?.</p>

<p>In the next practical you will perform differential gene expression analysis, for which you will need biological replicates. In the directory &quot;split_800k/&quot; you will find paired end read sets corresponding to six bank vole individuals (=biological replicates). Move all files that end in the same suffix (e.g. .aa, or .ab) in your directory using a wildcard. </p>

<div><pre><code class="language-none">mv *.aa /path/to/your/directory</code></pre></div>

<p>You should now have a total of 12 files: 6 biological replicates times two, as it is paired-end data. Use the <code>align_and_estimate_abundance.pl</code> script to map to TrinityB assembly and count expression levels. Do this to all six of the replicates to produce six individual <code>RSEM.isoform.results</code>. Note that you can use a sample list so you don’t have to input the command separately for each instance! Check the help file in the script on how to use the option. </p>

<div><pre><code class="language-none">align_and_estimate_abundance.pl -h</code></pre></div>

<p>Once you have your counts, use the <code>abundance_estimates_to_matrix.pl</code> script to consolidate the counts into a single expression matrix. For this step and onward you will need to load the<code>R</code> environment at CSC. </p>

<div><pre><code class="language-none">module load r-env-singularity </code></pre></div>

<p>Then run the script as below</p>

<div><pre><code class="language-none">$TRINITY_HOME/util/abundance_estimates_to_matrix.pl\
--est_method RSEM \
--gene_trans_map genetransmap \
--name_sample_by_basedir sample1.isoform.results \
sample2.isoform.results \
sample3.isoform.results \
sample4.isoform.results \
sample5.isoform.results \
sample6.isoform.results </code></pre></div>




</body>

</html>
